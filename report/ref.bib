
@incollection{blanchette_nitpick:_2010,
  title = {Nitpick: {{A Counterexample Generator}} for {{Higher}}-{{Order Logic Based}} on a {{Relational Model Finder}}},
  shorttitle = {Nitpick},
  abstract = {Nitpick is a counterexample generator for Isabelle/HOL that builds on Kodkod, a SAT-based first-order relational model finder. Nitpick supports unbounded quantification, (co)inductive predicates and datatypes, and (co)recursive functions. Fundamentally a finite model finder, it approximates infinite types by finite subsets. As case studies, we consider a security type system and a hotel key card system. Our experimental results on Isabelle theories and the TPTP library indicate that Nitpick generates more counterexamples than other model finders for higher-order logic, without restrictions on the form of the formulas to falsify.},
  language = {en},
  timestamp = {2016-11-24T01:04:11Z},
  urldate = {2016-11-24},
  note = {\url{http://link.springer.com/chapter/10.1007/978-3-642-14052-5_11}},
  booktitle = {{{SpringerLink}}},
  publisher = {{Springer Berlin Heidelberg}},
  author = {Blanchette, Jasmin Christian and Nipkow, Tobias},
  month = jul,
  year = {2010},
  pages = {131--146},
  file = {Full Text PDF:/home/cs4/dac31/.zotero/zotero/ol9d6r4h.default/zotero/storage/Z8E26PX9/Blanchette and Nipkow - 2010 - Nitpick A Counterexample Generator for Higher-Ord.pdf:application/pdf;Snapshot:/home/cs4/dac31/.zotero/zotero/ol9d6r4h.default/zotero/storage/9Q83685F/978-3-642-14052-5_11.html:text/html},
  doi = {10.1007/978-3-642-14052-5_11}
}

@inproceedings{barnett_spec_2005,
  address = {Berlin, Heidelberg},
  series = {CASSIS'04},
  title = {The {{Spec}}\# {{Programming System}}: {{An Overview}}},
  isbn = {978-3-540-24287-1},
  shorttitle = {The {{Spec}}\# {{Programming System}}},
  doi = {10.1007/978-3-540-30569-9_3},
  abstract = {The Spec\# programming system is a new attempt at a more cost effective way to develop and maintain high-quality software. This paper describes the goals and architecture of the Spec\# programming system, consisting of the object-oriented Spec\# programming language, the Spec\# compiler, and the Boogie static program verifier. The language includes constructs for writing specifications that capture programmer intentions about how methods and data are to be used, the compiler emits run-time checks to enforce these specifications, and the verifier can check the consistency between a program and its specifications.},
  timestamp = {2016-11-17T20:24:46Z},
  urldate = {2016-11-17},
  note = {\url{http://dx.doi.org/10.1007/978-3-540-30569-9_3}},
  booktitle = {Proceedings of the 2004 {{International Conference}} on {{Construction}} and {{Analysis}} of {{Safe}}, {{Secure}}, and {{Interoperable Smart Devices}}},
  publisher = {{Springer-Verlag}},
  author = {Barnett, Mike and Leino, K. Rustan M. and Schulte, Wolfram},
  year = {2005},
  pages = {49--69}
}

@inproceedings{berghofer_random_2004,
  address = {Washington, DC, USA},
  series = {SEFM '04},
  title = {Random {{Testing}} in {{Isabelle}}/{{HOL}}},
  isbn = {978-0-7695-2222-7},
  doi = {10.1109/SEFM.2004.36},
  abstract = {When developing non-trivial formalizations in a theorem prover, a considerable amount of time is devoted to "debugging" specifications and conjectures by failed proof attempts.To detect such problems early in the proof and save development time, we have extended the Isabelle theorem prover with a tool for testing specifications by evaluating propositions under an assignment of random values to free variables.Distribution of the test data is optimized via mutation testing.The technical contributions are an extension of earlier work with inductive definitions and a generic method for randomly generating elements of recursive datatypes.},
  timestamp = {2016-11-24T00:38:34Z},
  urldate = {2016-11-24},
  note = {\url{http://dx.doi.org/10.1109/SEFM.2004.36}},
  booktitle = {Proceedings of the {{Software Engineering}} and {{Formal Methods}}, {{Second International Conference}}},
  publisher = {{IEEE Computer Society}},
  author = {Berghofer, Stefan and Nipkow, Tobias},
  year = {2004},
  pages = {230--239}
}

@misc{_zotero_????,
  title = {Zotero | {{Download}}},
  timestamp = {2016-11-30T13:05:09Z},
  urldate = {2016-11-30},
  howpublished = {\url{https://www.zotero.org/download/}},
  file = {Zotero | Download:/home/cs4/dac31/.zotero/zotero/ol9d6r4h.default/zotero/storage/9IATH4UQ/download.html:text/html}
}

@article{claessen_quickcheck:_2011,
  title = {{{QuickCheck}}: {{A Lightweight Tool}} for {{Random Testing}} of {{Haskell Programs}}},
  volume = {46},
  issn = {0362-1340},
  shorttitle = {{{QuickCheck}}},
  doi = {10.1145/1988042.1988046},
  abstract = {QuickCheck is a tool which aids the Haskell programmer in formulating and testing properties of programs. Properties are discribed as Haskell functions, and can be automatically tested on random input, but it is also possible to define custom test data generators. We present a number of case studies, in which the tool was successfully used, and also point out some pitfalls to avoid. Random testing is especially suitable for functional programs because properties can be stated at a fine grain. When a function is built from separately tested components, then random testing suffuces to obtain good coverage of the definition under test.},
  timestamp = {2016-11-15T19:20:59Z},
  number = {4},
  urldate = {2016-11-15},
  note = {\url{http://doi.acm.org/10.1145/1988042.1988046}},
  journal = {SIGPLAN Not.},
  author = {Claessen, Koen and Hughes, John},
  month = may,
  year = {2011},
  pages = {53--64},
  file = {ACM Full Text PDF:/home/cs4/dac31/.zotero/zotero/ol9d6r4h.default/zotero/storage/ZZ3R4H9A/Claessen and Hughes - 2011 - QuickCheck A Lightweight Tool for Random Testing .pdf:application/pdf}
}

@book{paulson_isabelle:_1994-1,
  title = {Isabelle: {{A Generic Theorem Prover}}},
  isbn = {978-3-540-58244-1},
  shorttitle = {Isabelle},
  abstract = {As a generic theorem prover, Isabelle supports a variety of logics. Distinctive features include Isabelle's representation of logics within a meta-logic and the use of higher-order unification to combine inference rules. Isabelle can be applied to reasoning in pure mathematics or verification of computer systems. This volume constitutes the Isabelle documentation. It begins by outlining theoretical aspects and then demonstrates the use in practice. Virtually all Isabelle functions are described, with advice on correct usage and numerous examples. Isabelle's built-in logics are also described in detail. There is a comprehensive bebliography and index. The book addresses prospective users of Isabelle as well as researchers in logic and automated reasoning.},
  language = {en},
  timestamp = {2016-11-15T19:45:12Z},
  publisher = {{Springer Science \& Business Media}},
  author = {Paulson, Lawrence C.},
  month = jul,
  year = {1994},
  keywords = {Computers / Computer Science,Computers / Information Technology,Computers / Intelligence (AI) \& Semantics,Computers / Programming / General,Computers / Programming Languages / General,Computers / Software Development \& Engineering / General,Mathematics / Discrete Mathematics,Mathematics / History \& Philosophy,Mathematics / Logic}
}

@book{ould_testing_1986,
  title = {Testing in {{Software Development}}},
  isbn = {978-0-521-33786-1},
  abstract = {With the increasing application of software in systems, especially safety- or even life-critical systems, it is no longer sufficient for the software developer to rely solely on testing the code produced. Testing must begin with the specification of requirements, continue on the design and finally on the implemented system. This book gives guidance on how testing can be carried out at each of the stages of software development. It does this by looking at the development process from four viewpoints: that of the intended user of the system, of its designers, of its programmers, and of the manager responsible for development. The product of each stage of development is individually examined to see how it can be checked for correctness and consistency with earlier specifications. References are given to techniques available to the software developer and there are many helpful checklists. The contributors are all members of the British Computer Society's Working Group on Testing, and between them have an impressive breadth of practical experience in the commercial development of small and large software systems. Their combined experience makes this a most valuable book for the computing professional.},
  language = {en},
  timestamp = {2016-11-21T20:34:06Z},
  publisher = {{Cambridge University Press}},
  author = {Ould, Martyn A. and Unwin, Charles and on Testing, British Computer Society Working Group},
  month = dec,
  year = {1986},
  note = {Google-Books-ID: utFCImZOTEIC},
  keywords = {Computers / Electronic Commerce,Computers / Programming / General,Computers / Programming Languages / General,Computers / Software Development \& Engineering / General}
}

@misc{_pycharm_????,
  title = {{{PyCharm}}},
  abstract = {Intelligent Python IDE with refactorings, debugger, code completion, on-the-fly code analysis and coding productivity orientation},
  timestamp = {2016-11-30T12:08:54Z},
  urldate = {2016-11-30},
  howpublished = {\url{https://www.jetbrains.com/pycharm/}},
  journal = {JetBrains},
  file = {Snapshot:/home/cs4/dac31/.zotero/zotero/ol9d6r4h.default/zotero/storage/T84VD2DJ/pycharm.html:text/html}
}

@misc{_junit_????,
  title = {{{JUnit}} - {{About}}},
  timestamp = {2016-11-18T15:26:50Z},
  urldate = {2016-11-18},
  howpublished = {\url{http://junit.org/junit4/}},
  file = {JUnit - About:/home/cs4/dac31/.zotero/zotero/ol9d6r4h.default/zotero/storage/M8GSHX7Q/junit4.html:text/html}
}

@book{barnes_programming_2014,
  title = {Programming in {{Ada}} 2012},
  isbn = {978-1-107-42481-4},
  abstract = {Ada is the language of choice for the majority of programmers involved in writing safety-critical and high-integrity software. Previous editions of John Barnes' books established themselves as the definitive references for earlier versions of Ada. With the release of the latest ISO standard, Ada 2012, this new book will become recognised as the go-to resource for those wishing to learn the language or to program in it.},
  language = {en},
  timestamp = {2016-11-22T14:26:08Z},
  publisher = {{Cambridge University Press}},
  author = {Barnes, John},
  month = jun,
  year = {2014},
  note = {Google-Books-ID: qiWjAwAAQBAJ},
  keywords = {Computers / Programming / General,Computers / Programming Languages / General,Computers / Software Development \& Engineering / General}
}

@misc{_pep_????,
  title = {{{PEP}} 8 -- {{Style Guide}} for {{Python Code}}},
  abstract = {The official home of the Python Programming Language},
  timestamp = {2016-11-30T12:08:40Z},
  urldate = {2016-11-30},
  howpublished = {\url{https://www.python.org/dev/peps/pep-0008/}},
  journal = {Python.org},
  file = {Snapshot:/home/cs4/dac31/.zotero/zotero/ol9d6r4h.default/zotero/storage/M3XMDGND/pep-0008.html:text/html}
}

@inproceedings{jacobs_quick_2010,
  address = {Berlin, Heidelberg},
  series = {APLAS'10},
  title = {A {{Quick Tour}} of the {{VeriFast Program Verifier}}},
  isbn = {978-3-642-17163-5},
  abstract = {This paper describes the main features of VeriFast, a sound and modular program verifier for C and Java. VeriFast takes as input a number of source files annotated with method contracts written in separation logic, inductive data type and fixpoint definitions, lemma functions and proof steps. The verifier checks that (1) the program does not perform illegal operations such as dividing by zero or illegal memory accesses and (2) that the assumptions described in method contracts hold in each execution. Although VeriFast supports specifying and verifying deep data structure properties, it provides an interactive verification experience as verification times are consistently low and errors can be diagnosed using its symbolic debugger. VeriFast and a large number of example programs are available online at: http://www.cs.kuleuven.be/\textasciitilde{}bartj/verifast},
  timestamp = {2016-11-17T20:27:41Z},
  urldate = {2016-11-17},
  note = {\url{http://dl.acm.org/citation.cfm?id=1947873.1947902}},
  booktitle = {Proceedings of the 8th {{Asian Conference}} on {{Programming Languages}} and {{Systems}}},
  publisher = {{Springer-Verlag}},
  author = {Jacobs, Bart and Smans, Jan and Piessens, Frank},
  year = {2010},
  pages = {304--311}
}

@misc{_virtual_????,
  title = {Virtual {{Environments}} \textemdash{} {{The Hitchhiker}}'s {{Guide}} to {{Python}}},
  timestamp = {2016-11-30T13:05:19Z},
  urldate = {2016-11-30},
  howpublished = {\url{http://docs.python-guide.org/en/latest/dev/virtualenvs/}},
  file = {Virtual Environments — The Hitchhiker's Guide to Python:/home/cs4/dac31/.zotero/zotero/ol9d6r4h.default/zotero/storage/TRKFRC3W/virtualenvs.html:text/html}
}

@incollection{barnett_boogie:_????,
  title = {Boogie: {{A Modular Reusable Verifier}} for {{Object}}-{{Oriented Programs}}},
  shorttitle = {Boogie},
  abstract = {A program verifier is a complex system that uses compiler technology, program semantics, property inference, verification-condition generation, automatic decision procedures, and a user interface. This paper describes the architecture of a state-of-the-art program verifier for object-oriented programs.},
  language = {en},
  timestamp = {2016-11-21T17:49:24Z},
  urldate = {2016-11-21},
  note = {\url{http://link.springer.com/chapter/10.1007/11804192_17}},
  booktitle = {{{SpringerLink}}},
  publisher = {{Springer Berlin Heidelberg}},
  author = {Barnett, Mike and Chang, Bor-Yuh Evan and DeLine, Robert and Jacobs, Bart and Leino, K. Rustan M.},
  pages = {364--387},
  file = {Full Text PDF:/home/cs4/dac31/.zotero/zotero/ol9d6r4h.default/zotero/storage/AXPEI2NQ/Barnett et al. - Boogie A Modular Reusable Verifier for Object-Ori.pdf:application/pdf;Snapshot:/home/cs4/dac31/.zotero/zotero/ol9d6r4h.default/zotero/storage/S8TDWB7H/10.html:text/html},
  doi = {10.1007/11804192_17}
}

@misc{_nunit_????,
  title = {{{NUnit}} - {{Home}}},
  timestamp = {2016-11-23T23:51:50Z},
  urldate = {2016-11-23},
  howpublished = {\url{https://www.nunit.org/}},
  file = {NUnit - Home:/home/cs4/dac31/.zotero/zotero/ol9d6r4h.default/zotero/storage/H3F4HSGW/www.nunit.org.html:text/html}
}

@incollection{moura_z3:_????,
  title = {Z3: {{An Efficient SMT Solver}}},
  shorttitle = {Z3},
  abstract = {Satisfiability Modulo Theories (SMT) problem is a decision problem for logical first order formulas with respect to combinations of background theories such as: arithmetic, bit-vectors, arrays, and uninterpreted functions. Z3 is a new and efficient SMT Solver freely available from Microsoft Research. It is used in various software verification and analysis applications.},
  language = {en},
  timestamp = {2016-11-21T17:32:27Z},
  urldate = {2016-11-21},
  note = {\url{http://link.springer.com/chapter/10.1007/978-3-540-78800-3_24}},
  booktitle = {{{SpringerLink}}},
  publisher = {{Springer Berlin Heidelberg}},
  author = {de Moura, Leonardo and Bj\o{}rner, Nikolaj},
  pages = {337--340},
  file = {Full Text PDF:/home/cs4/dac31/.zotero/zotero/ol9d6r4h.default/zotero/storage/JGCEE4RV/Moura and Bjørner - Z3 An Efficient SMT Solver.pdf:application/pdf;Snapshot:/home/cs4/dac31/.zotero/zotero/ol9d6r4h.default/zotero/storage/R27RJW6A/978-3-540-78800-3_24.html:text/html},
  doi = {10.1007/978-3-540-78800-3_24}
}

@book{martin_clean_2008,
  address = {Upper Saddle River, NJ},
  edition = {1 edition},
  title = {Clean {{Code}}: {{A Handbook}} of {{Agile Software Craftsmanship}}},
  isbn = {978-0-13-235088-4},
  shorttitle = {Clean {{Code}}},
  abstract = {Even bad code can function. But if code isn't clean, it can bring a development organization to its knees. Every year, countless hours and significant resources are lost because of poorly written code. But it doesn't have to be that way.  Noted software expert Robert C. Martin presents a revolutionary paradigm with Clean Code: A Handbook of Agile Software Craftsmanship . Martin has teamed up with his colleagues from Object Mentor to distill their best agile practice of cleaning code ``on the fly'' into a book that will instill within you the values of a software craftsman and make you a better programmer\textemdash{}but only if you work at it.  What kind of work will you be doing? You'll be reading code\textemdash{}lots of code. And you will be challenged to think about what's right about that code, and what's wrong with it. More importantly, you will be challenged to reassess your professional values and your commitment to your craft.  Clean Code is divided into three parts. The first describes the principles, patterns, and practices of writing clean code. The second part consists of several case studies of increasing complexity. Each case study is an exercise in cleaning up code\textemdash{}of transforming a code base that has some problems into one that is sound and efficient. The third part is the payoff: a single chapter containing a list of heuristics and ``smells'' gathered while creating the case studies. The result is a knowledge base that describes the way we think when we write, read, and clean code.  Readers will come away from this book understanding      How to tell the difference between good and bad code     How to write good code and how to transform bad code into good code     How to create good names, good functions, good objects, and good classes     How to format code for maximum readability     How to implement complete error handling without obscuring code logic     How to unit test and practice test-driven development  This book is a must for any developer, software engineer, project manager, team lead, or systems analyst with an interest in producing better code.},
  language = {English},
  timestamp = {2016-11-30T12:09:09Z},
  publisher = {{Prentice Hall}},
  author = {Martin, Robert C.},
  month = aug,
  year = {2008}
}

@incollection{leino_verification_2009,
  series = {Lecture Notes in Computer Science},
  title = {Verification of {{Concurrent Programs}} with {{Chalice}}},
  copyright = {\textcopyright{}2009 Springer-Verlag Berlin Heidelberg},
  isbn = {978-3-642-03828-0 978-3-642-03829-7},
  abstract = {A program verifier is a tool that allows developers to prove that their code satisfies its specification for every possible input and every thread schedule. These lecture notes describe a verifier for concurrent programs called Chalice. Chalice's verification methodology centers around permissions and permission transfer. In particular, a memory location may be accessed by a thread only if that thread has permission to do so. Proper use of permissions allows Chalice to deduce upper bounds on the set of locations modifiable by a method and guarantees the absence of data races for concurrent programs. The lecture notes informally explain how Chalice works through various examples.},
  language = {en},
  timestamp = {2016-11-21T18:01:13Z},
  number = {5705},
  urldate = {2016-11-21},
  note = {\url{http://link.springer.com/chapter/10.1007/978-3-642-03829-7_7}},
  booktitle = {Foundations of {{Security Analysis}} and {{Design V}}},
  publisher = {{Springer Berlin Heidelberg}},
  author = {Leino, K. Rustan M. and M{\"u}ller, Peter and Smans, Jan},
  editor = {Aldini, Alessandro and Barthe, Gilles and Gorrieri, Roberto},
  year = {2009},
  keywords = {Computer Communication Networks,Data Encryption,Logics and Meanings of Programs,Management of Computing and Information Systems,Programming Languages; Compilers; Interpreters,Systems and Data Security},
  pages = {195--222},
  file = {Full Text PDF:/home/cs4/dac31/.zotero/zotero/ol9d6r4h.default/zotero/storage/G23XTMJB/Leino et al. - 2009 - Verification of Concurrent Programs with Chalice.pdf:application/pdf;Snapshot:/home/cs4/dac31/.zotero/zotero/ol9d6r4h.default/zotero/storage/U3V7TUHH/978-3-642-03829-7_7.html:text/html},
  doi = {10.1007/978-3-642-03829-7_7}
}

@misc{_quickcheck_????,
  title = {A {{QuickCheck Tutorial}}: {{Generators}}},
  timestamp = {2016-11-23T17:09:50Z},
  urldate = {2016-11-23},
  howpublished = {\url{https://www.stackbuilders.com/news/a-quickcheck-tutorial-generators}},
  file = {A QuickCheck Tutorial\: Generators:/home/cs4/dac31/.zotero/zotero/ol9d6r4h.default/zotero/storage/XG9CQ6QF/a-quickcheck-tutorial-generators.html:text/html}
}

@article{meyer_programs_2009,
  title = {Programs {{That Test Themselves}}},
  volume = {42},
  issn = {0018-9162},
  doi = {10.1109/MC.2009.296},
  timestamp = {2016-11-15T19:36:15Z},
  number = {9},
  urldate = {2016-11-15},
  note = {\url{http://ieeexplore.ieee.org/document/5233506/}},
  journal = {Computer},
  author = {Meyer, Bertrand and Fiva, Arno and Ciupa, Ilinca and Leitner, Andreas and Wei, Yi and Stapf, Emmanuel},
  month = sep,
  year = {2009},
  pages = {46--55}
}

@article{malenfant_tutorial_1996,
  title = {A {{Tutorial}} on {{Behavioral Reflection}} and Its {{Implementation}}},
  abstract = {The eecient implementation of behaviorally reeec-tive languages imposes a formidable challenge. By deenition, behavioral reeection allows a program to modify, e v en at run-time, its own code as...},
  timestamp = {2016-11-17T20:44:14Z},
  urldate = {2016-11-17},
  note = {\url{https://www.researchgate.net/publication/243671255_A_Tutorial_on_Behavioral_Reflection_and_its_Implementation}},
  journal = {ResearchGate},
  author = {Malenfant, J. and Jacques, M. and Demers, F. N.},
  month = jan,
  year = {1996},
  file = {Snapshot:/home/cs4/dac31/.zotero/zotero/ol9d6r4h.default/zotero/storage/FI7Z24XI/243671255_A_Tutorial_on_Behavioral_Reflection_and_its_Implementation.html:text/html}
}

@inproceedings{cohen_vcc:_2009,
  address = {Berlin, Heidelberg},
  series = {TPHOLs '09},
  title = {{{VCC}}: {{A Practical System}} for {{Verifying Concurrent C}}},
  isbn = {978-3-642-03358-2},
  shorttitle = {{{VCC}}},
  doi = {10.1007/978-3-642-03359-9_2},
  abstract = {VCC is an industrial-strength verification environment for low-level concurrent system code written in C. VCC takes a program (annotated with function contracts, state assertions, and type invariants) and attempts to prove the correctness of these annotations. It includes tools for monitoring proof attempts and constructing partial counterexample executions for failed proofs. This paper motivates VCC, describes our verification methodology, describes the architecture of VCC, and reports on our experience using VCC to verify the Microsoft Hyper-V hypervisor.},
  timestamp = {2016-11-17T20:25:17Z},
  urldate = {2016-11-17},
  note = {\url{http://dx.doi.org/10.1007/978-3-642-03359-9_2}},
  booktitle = {Proceedings of the {{22Nd International Conference}} on {{Theorem Proving}} in {{Higher Order Logics}}},
  publisher = {{Springer-Verlag}},
  author = {Cohen, Ernie and Dahlweid, Markus and Hillebrand, Mark and Leinenbach, Dirk and Moskal, Micha$\backslash$l and Santen, Thomas and Schulte, Wolfram and Tobies, Stephan},
  year = {2009},
  pages = {23--42}
}

@incollection{fahndrich_static_2010,
  title = {Static {{Verification}} for {{Code Contracts}}},
  abstract = {The Code Contracts project [3] at Microsoft Research enables programmers on the .NET platform to author specifications in existing languages such as C\# and VisualBasic. To take advantage of these specifications, we provide tools for documentation generation, runtime contract checking, and static contract verification.This talk details the overall approach of the static contract checker and examines where and how we trade-off soundness in order to obtain a practical tool that works on a full-fledged object-oriented intermediate language such as the .NET Common Intermediate Language.},
  language = {en},
  timestamp = {2016-11-24T00:06:42Z},
  urldate = {2016-11-24},
  note = {\url{http://link.springer.com/chapter/10.1007/978-3-642-15769-1_2}},
  booktitle = {{{SpringerLink}}},
  publisher = {{Springer Berlin Heidelberg}},
  author = {F{\"a}hndrich, Manuel},
  month = sep,
  year = {2010},
  pages = {2--5},
  file = {Full Text PDF:/home/cs4/dac31/.zotero/zotero/ol9d6r4h.default/zotero/storage/T222WJTG/Fähndrich - 2010 - Static Verification for Code Contracts.pdf:application/pdf;Snapshot:/home/cs4/dac31/.zotero/zotero/ol9d6r4h.default/zotero/storage/6RDR8R6U/978-3-642-15769-1_2.html:text/html},
  doi = {10.1007/978-3-642-15769-1_2}
}

@misc{_ieee_????,
  title = {{{IEEE SA}} - 1008-1987 - {{IEEE Standard}} for {{Software Unit Testing}}},
  timestamp = {2016-11-15T20:16:34Z},
  urldate = {2016-11-15},
  howpublished = {\url{https://standards.ieee.org/findstds/standard/1008-1987.html}},
  file = {IEEE SA - 1008-1987 - IEEE Standard for Software Unit Testing:/home/cs4/dac31/.zotero/zotero/ol9d6r4h.default/zotero/storage/CE3ABV6A/1008-1987.html:text/html}
}

@misc{_csharpcodeprovider_????,
  title = {{{CSharpCodeProvider Class}} ({{Microsoft}}.{{CSharp}})},
  timestamp = {2016-11-24T04:12:11Z},
  urldate = {2016-11-24},
  howpublished = {\url{https://msdn.microsoft.com/en-us/library/microsoft.csharp.csharpcodeprovider(v=vs.110).aspx}},
  file = {CSharpCodeProvider Class (Microsoft.CSharp):/home/cs4/dac31/.zotero/zotero/ol9d6r4h.default/zotero/storage/TAK9DTN9/microsoft.csharp.csharpcodeprovider(v=vs.110).html:text/html}
}

@article{spivey_introduction_1989,
  title = {An Introduction to {{Z}} and Formal Specifications},
  volume = {4},
  issn = {0268-6961},
  doi = {10.1049/sej.1989.0006},
  abstract = {The description of information systems using formal, mathematical specifications written in the Z notation, and the refinement of these specifications into rigorously checked designs are described. The author introduces the idea of a formal specification using a simple example: a 'birthday book' in which people's birthdays can be recorded, and which is able to issue reminders on the appropriate day. The behaviour of this system for correct input is specified; then the schema calculus is used to strengthen the specification into one requiring error reports for incorrect input. The idea of data refinement as the primary means of constructing designs which achieve a formal specification is also demonstrated.$<$$>$},
  timestamp = {2016-11-17T21:14:19Z},
  number = {1},
  journal = {Software Engineering Journal},
  author = {Spivey, J. M.},
  month = jan,
  year = {1989},
  keywords = {birthday book,correct input,data refinement,error reports,formal languages,formal specification,information systems,mathematical specifications,programming,rigorously checked designs,schema calculus,Software requirements and specifications,specification languages,Z notation},
  pages = {40--50},
  file = {IEEE Xplore Full Text PDF:/home/cs4/dac31/.zotero/zotero/ol9d6r4h.default/zotero/storage/WFAJ4AZJ/Spivey - 1989 - An introduction to Z and formal specifications.pdf:application/pdf;IEEE Xplore Abstract Record:/home/cs4/dac31/.zotero/zotero/ol9d6r4h.default/zotero/storage/XUDRIM4N/28089.html:text/html}
}

@misc{_microsoft/dafny_????,
  title = {Microsoft/Dafny},
  abstract = {dafny - Dafny is a verification-aware programming language},
  timestamp = {2016-11-17T21:41:10Z},
  urldate = {2016-11-17},
  howpublished = {\url{https://github.com/Microsoft/dafny}},
  journal = {GitHub},
  file = {Snapshot:/home/cs4/dac31/.zotero/zotero/ol9d6r4h.default/zotero/storage/7ACMV7UC/dafny.html:text/html}
}

@inproceedings{grov_annotation_????,
  title = {Annotation {{Overheads Revisited}}},
  timestamp = {2016-11-23T19:02:09Z},
  author = {Grov, Gudmund and Cameron, Duncan and McGregor, L{\'e}on}
}

@incollection{bulwahn_new_????,
  title = {The {{New Quickcheck}} for {{Isabelle}}},
  abstract = {The new Quickcheck is a counterexample generator for Isabelle/HOL that uncovers faulty specifications and invalid conjectures using various testing strategies. The previous Quickcheck only tested conjectures by random testing. The new Quickcheck extends the previous one and integrates two novel testing strategies: exhaustive testing with concrete values; and symbolic testing, evaluating conjectures with a narrowing strategy. Orthogonally to the strategies, we address two general issues: First, we extend the class of executable conjectures and specifications, and second, we present techniques to deal with conditional conjectures, i.e., conjectures with premises. We evaluate the testing strategies and techniques on a number of specifications, functional data structures and a hotel key card system.},
  language = {en},
  timestamp = {2016-11-15T19:25:34Z},
  urldate = {2016-11-15},
  note = {\url{http://link.springer.com/chapter/10.1007/978-3-642-35308-6_10}},
  booktitle = {{{SpringerLink}}},
  publisher = {{Springer Berlin Heidelberg}},
  author = {Bulwahn, Lukas},
  pages = {92--108},
  file = {Full Text PDF:/home/cs4/dac31/.zotero/zotero/ol9d6r4h.default/zotero/storage/CR8SMGN4/Bulwahn - The New Quickcheck for Isabelle.pdf:application/pdf;Snapshot:/home/cs4/dac31/.zotero/zotero/ol9d6r4h.default/zotero/storage/XW4VZ5EE/978-3-642-35308-6_10.html:text/html},
  doi = {10.1007/978-3-642-35308-6_10}
}

@book{mccormick_building_2015,
  address = {New York, NY},
  title = {Building High Integrity Applications with {{SPARK}}},
  isbn = {978-1-107-65684-0 978-1-107-04073-1},
  language = {eng},
  timestamp = {2016-11-17T20:27:19Z},
  publisher = {{Cambridge University Press}},
  author = {McCormick, John W. and Chapin, Peter C.},
  year = {2015},
  note = {OCLC: 932128992},
  keywords = {Fault-tolerant computing,SPARK (Computer program language)},
  annote = {Hier auch sp{\"a}ter erschienene, unver{\"a}nderte Nachdrucke Includes bibliographical references (pages 359-362) and index},
  file = {Table of Contents PDF:/home/cs4/dac31/.zotero/zotero/ol9d6r4h.default/zotero/storage/ANCSWSM2/McCormick and Chapin - 2015 - Building high integrity applications with SPARK.pdf:application/pdf}
}

@misc{_boogie-org/boogie_????,
  title = {Boogie-Org/Boogie},
  abstract = {boogie - Boogie},
  timestamp = {2016-11-23T23:54:59Z},
  urldate = {2016-11-23},
  howpublished = {\url{https://github.com/boogie-org/boogie}},
  journal = {GitHub},
  file = {Snapshot:/home/cs4/dac31/.zotero/zotero/ol9d6r4h.default/zotero/storage/MUQJAG7T/boogie.html:text/html}
}

@book{black_managing_2002,
  address = {New York},
  edition = {2nd ed},
  title = {Managing the Testing Process: Practical Tools and Techniques for Managing Hardware and Software Testing},
  isbn = {978-0-471-22398-6},
  lccn = {QA76.76.T48 B553 2002},
  shorttitle = {Managing the Testing Process},
  timestamp = {2016-11-21T20:37:44Z},
  publisher = {{Wiley}},
  author = {Black, Rex},
  year = {2002},
  note = {OCLC: ocm49775344},
  keywords = {Computers,Computer software,Testing}
}

@misc{_fscheck/fscheck_????,
  title = {Fscheck/{{FsCheck}}},
  abstract = {FsCheck - Random Testing for .NET},
  timestamp = {2016-11-18T15:34:27Z},
  urldate = {2016-11-18},
  howpublished = {\url{https://github.com/fscheck/FsCheck}},
  journal = {GitHub},
  file = {Snapshot:/home/cs4/dac31/.zotero/zotero/ol9d6r4h.default/zotero/storage/R7KCBPB6/FsCheck.html:text/html}
}

@incollection{abrial_b-method_1991,
  series = {Lecture Notes in Computer Science},
  title = {The {{B}}-Method},
  copyright = {\textcopyright{}1991 BP International Ltd},
  isbn = {978-3-540-54868-3 978-3-540-46456-3},
  abstract = {The B-method is designed to provide a homogeneous language and a methodology for the formal specification, design and implementation of real-life software systems. Therefore, the features of incremental construction and proof have been guiding principles in its development. A full account of the B-method and its theoretical foundations is to appear shortly as a book by J.-R. Abrial. An environment, the B Toolkit, supports formal development activities from specification to coding. The toolkit itself is supported by a platform, the B-tool, which is now commercially available from Edinburgh Portable Compilers Ltd. The B Toolkit will soon be ready for alpha testing, and it is planned to make it commercially available in due course.},
  language = {en},
  timestamp = {2016-11-21T19:11:50Z},
  number = {552},
  urldate = {2016-11-21},
  note = {\url{http://link.springer.com/chapter/10.1007/BFb0020001}},
  booktitle = {{{VDM}} '91 {{Formal Software Development Methods}}},
  publisher = {{Springer Berlin Heidelberg}},
  author = {Abrial, J.-R. and Lee, M. K. O. and Neilson, D. S. and Scharbach, P. N. and S\o{}rensen, I. H.},
  editor = {Prehn, S\o{}ren and Toetenel, Hans},
  month = oct,
  year = {1991},
  keywords = {Logics and Meanings of Programs,Software Engineering,Software Engineering/Programming and Operating Systems,Theory of Computation},
  pages = {398--405},
  file = {Snapshot:/home/cs4/dac31/.zotero/zotero/ol9d6r4h.default/zotero/storage/AUPJMXZ5/BFb0020001.html:text/html},
  doi = {10.1007/BFb0020001}
}

@misc{_pholser/junit-quickcheck_????,
  title = {Pholser/Junit-Quickcheck},
  abstract = {junit-quickcheck - Property-based testing, JUnit-style},
  timestamp = {2016-11-21T15:56:39Z},
  urldate = {2016-11-21},
  howpublished = {\url{https://github.com/pholser/junit-quickcheck}},
  journal = {GitHub},
  file = {Snapshot:/home/cs4/dac31/.zotero/zotero/ol9d6r4h.default/zotero/storage/XF3IAC3S/junit-quickcheck.html:text/html}
}

@incollection{leino_dafny:_????,
  title = {Dafny: {{An Automatic Program Verifier}} for {{Functional Correctness}}},
  shorttitle = {Dafny},
  abstract = {Traditionally, the full verification of a program's functional correctness has been obtained with pen and paper or with interactive proof assistants, whereas only reduced verification tasks, such as extended static checking, have enjoyed the automation offered by satisfiability-modulo-theories (SMT) solvers. More recently, powerful SMT solvers and well-designed program verifiers are starting to break that tradition, thus reducing the effort involved in doing full verification.This paper gives a tour of the language and verifier Dafny, which has been used to verify the functional correctness of a number of challenging pointer-based programs. The paper describes the features incorporated in Dafny, illustrating their use by small examples and giving a taste of how they are coded for an SMT solver. As a larger case study, the paper shows the full functional specification of the Schorr-Waite algorithm in Dafny.},
  language = {en},
  timestamp = {2016-11-17T20:23:28Z},
  urldate = {2016-11-17},
  note = {\url{http://link.springer.com/chapter/10.1007/978-3-642-17511-4_20}},
  booktitle = {{{SpringerLink}}},
  publisher = {{Springer Berlin Heidelberg}},
  author = {Leino, K. Rustan M.},
  pages = {348--370},
  file = {Full Text PDF:/home/cs4/dac31/.zotero/zotero/ol9d6r4h.default/zotero/storage/ZHESEW46/Leino - Dafny An Automatic Program Verifier for Functiona.pdf:application/pdf;Snapshot:/home/cs4/dac31/.zotero/zotero/ol9d6r4h.default/zotero/storage/4HGS96SF/10.html:text/html},
  doi = {10.1007/978-3-642-17511-4_20}
}

@incollection{leino_verified_????,
  title = {Verified {{Calculations}}},
  abstract = {Calculational proofs\textemdash{}proofs by stepwise formula manipulation\textemdash{}are praised for their rigor, readability, and elegance. It seems desirable to reuse this style, often employed on paper, in the context of mechanized reasoning, and in particular, program verification.This work leverages the power of SMT solvers to machine-check calculational proofs at the level of detail they are usually written by hand. It builds the support for calculations into the programming language and auto-active program verifier Dafny. The paper demonstrates that calculations integrate smoothly with other language constructs, producing concise and readable proofs in a wide range of problem domains: from mathematical theorems to correctness of imperative programs. The examples show that calculational proofs in Dafny compare favorably, in terms of readability and conciseness, with arguments written in other styles and proof languages.},
  language = {en},
  timestamp = {2016-11-21T18:55:27Z},
  urldate = {2016-11-21},
  note = {\url{http://link.springer.com/chapter/10.1007/978-3-642-54108-7_9}},
  booktitle = {{{SpringerLink}}},
  publisher = {{Springer Berlin Heidelberg}},
  author = {Leino, K. Rustan M. and Polikarpova, Nadia},
  pages = {170--190},
  file = {Full Text PDF:/home/cs4/dac31/.zotero/zotero/ol9d6r4h.default/zotero/storage/2NTAS23R/Leino and Polikarpova - Verified Calculations.pdf:application/pdf;Snapshot:/home/cs4/dac31/.zotero/zotero/ol9d6r4h.default/zotero/storage/HZSNJJ26/978-3-642-54108-7_9.html:text/html},
  doi = {10.1007/978-3-642-54108-7_9}
}

@book{paulson_isabelle:_1994,
  address = {Berlin ; New York},
  series = {Lecture notes in computer science},
  title = {Isabelle: A Generic Theorem Prover},
  isbn = {978-3-540-58244-1 978-0-387-58244-3},
  lccn = {QA76.9.A96 P38 1994},
  shorttitle = {Isabelle},
  timestamp = {2016-11-17T20:38:33Z},
  number = {828},
  publisher = {{Springer-Verlag}},
  author = {Paulson, Lawrence C. and Nipkow, Tobias},
  year = {1994},
  keywords = {Automatic theorem proving,Isabelle (Computer file)}
}

@comment{jabref-meta: groupsversion:3;}
@comment{jabref-meta: groupstree:
0 AllEntriesGroup:;
1 ExplicitGroup:Industrial Programming\;0\;_pep_????\;_pycharm_????\;m
artin_clean_2008\;_virtual_????\;;
}

